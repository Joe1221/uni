\ProvidesExplPackage {l3backports} {2013/11/16} {0.1}
	{}

\cs_if_exist:NF \str_case_x:nnF {

% \begin{macro}[pTF, EXP]{\str_if_eq:nn, \str_if_eq_x:nn}
%   Modern engines provide a direct way of comparing two token lists,
%   but returning a number. This set of conditionals therefore make life
%   a bit clearer. The \texttt{nn} and \texttt{xx} versions are created
%   directly as this is most efficient. These should eventually
%   move somewhere else.
%    \begin{macrocode}
%\prg_new_conditional:Npnn \str_if_eq:nn #1#2 { p , T , F , TF }
%  {
%    \if_int_compare:w \pdftex_strcmp:D { \exp_not:n {#1} } { \exp_not:n {#2} }
%      = \c_zero
%      \prg_return_true: \else: \prg_return_false: \fi:
%  }
\prg_new_conditional:Npnn \str_if_eq_x:nn #1#2 { p , T , F , TF }
  {
    \if_int_compare:w \pdftex_strcmp:D {#1} {#2} = \c_zero
      \prg_return_true: \else: \prg_return_false: \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\__str_if_eq_x_return:nn}
%   It turns out that we often need to compare a token list
%   with the result of applying some function to it, and
%   return with \cs{prg_return_true/false:}. This test is
%   similar to \cs{str_if_eq:nnTF}, but hard-coded for speed.
%    \begin{macrocode}
\cs_new:Npn \__str_if_eq_x_return:nn #1 #2
  {
    \if_int_compare:w \pdftex_strcmp:D {#1} {#2} = \c_zero
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\str_case:nn, \str_case_x:nn}
% \begin{macro}[EXP, TF]{\str_case:nn, \str_case_x:nn}
% \begin{macro}[EXP, aux]{\__str_case:nnTF, \__str_case_x:nnTF}
% \begin{macro}[int, EXP]{\__prg_case_end:nw}
% \begin{macro}[aux, EXP]
%   {\__str_case:nw, \__str_case_x:nw, \__str_case_end:nw}
%   The aim here is to allow the case statement to be evaluated
%   using a known number of expansion steps (two), and without
%   needing to use an explicit \enquote{end of recursion} marker.
%   That is achieved by using the test input as the final case,
%   as this will always be true. The trick is then to tidy up
%   the output such that the appropriate case code plus either
%   the \texttt{true} or \texttt{false} branch code is inserted.
%    \begin{macrocode}
\cs_new:Npn \str_case:nn #1#2
  {
    \tex_romannumeral:D
    \__str_case:nnTF {#1} {#2} { } { }
  }
\cs_new:Npn \str_case:nnT #1#2#3
  {
    \tex_romannumeral:D
    \__str_case:nnTF {#1} {#2} {#3} { }
  }
\cs_new:Npn \str_case:nnF #1#2
  {
    \tex_romannumeral:D
    \__str_case:nnTF {#1} {#2} { }
  }
\cs_new:Npn \str_case:nnTF #1#2
  {
    \tex_romannumeral:D
    \__str_case:nnTF {#1} {#2}
  }
\cs_new:Npn \__str_case:nnTF #1#2#3#4
  { \__str_case:nw {#1} #2 {#1} { } \q_mark {#3} \q_mark {#4} \q_stop }
\cs_new:Npn \__str_case:nw #1#2#3
  {
    \str_if_eq:nnTF {#1} {#2}
      { \__str_case_end:nw {#3} }
      { \__str_case:nw {#1} }
  }
\cs_new:Npn \str_case_x:nn #1#2
  {
    \tex_romannumeral:D
    \__str_case_x:nnTF {#1} {#2} { } { }
  }
\cs_new:Npn \str_case_x:nnT #1#2#3
  {
    \tex_romannumeral:D
    \__str_case_x:nnTF {#1} {#2} {#3} { }
  }
\cs_new:Npn \str_case_x:nnF #1#2
  {
    \tex_romannumeral:D
    \__str_case_x:nnTF {#1} {#2} { }
  }
\cs_new:Npn \str_case_x:nnTF #1#2
  {
    \tex_romannumeral:D
    \__str_case_x:nnTF {#1} {#2}
  }
\cs_new:Npn \__str_case_x:nnTF #1#2#3#4
  { \__str_case_x:nw {#1} #2 {#1} { } \q_mark {#3} \q_mark {#4} \q_stop }
\cs_new:Npn \__str_case_x:nw #1#2#3
  {
    \str_if_eq_x:nnTF {#1} {#2}
      { \__str_case_end:nw {#3} }
      { \__str_case_x:nw {#1} }
  }
%    \end{macrocode}
%   To tidy up the recursion, there are two outcomes. If there was a hit to
%   one of the cases searched for, then |#1| will be the code to insert,
%   |#2| will be the \emph{next} case to check on and |#3| will be all of
%   the rest of the cases code. That means that |#4| will be the \texttt{true}
%   branch code, and |#5| will be tidy up the spare \cs{q_mark} and the
%   \texttt{false} branch. On the other hand, if none of the cases matched
%   then we arrive here using the \enquote{termination} case of comparing
%   the search with itself. That means that |#1| will be empty, |#2| will be
%   the first \cs{q_mark} and so |#4| will be the \texttt{false} code (the
%   \texttt{true} code is mopped up by |#3|).
%    \begin{macrocode}
\cs_new:Npn \__prg_case_end:nw #1#2#3 \q_mark #4#5 \q_stop
  { \c_zero #1 #4 }
\cs_new_eq:NN \__str_case_end:nw \__prg_case_end:nw
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}

}
